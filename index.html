<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
		<meta http-equiv='X-UA-Compatible' content='IE=edge'>
		<title>Protein-Go demo</title>
		<script src='https://aframe.io/releases/0.9.2/aframe.min.js'></script>
		<script src="https://cdn.rawgit.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.js"></script>
	   	<script src="https://google-ar.github.io/three.ar.js/dist/three.ar.js"></script>
		<script src="https://rawgit.com/chenzlabs/aframe-ar/827e9db/dist/aframe-ar.min.js"></script>
		<script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/cfe5f316/dist/aframe-extras.js"></script>
	</head>
	<body style='margin: 0; overflow: hidden;'>
		<a-scene ar vr-mode-ui="enabled: false"
				embedded 
			 arjs='sourceType: webcam; sourceWidth:1280; sourceHeight:960; displayWidth: 1280; 
			       displayHeight: 960; debugUIEnabled: false; trackingMethod: best;' 
			 webxr="requiredFeatures: hit-test,local-floor;
				optionalFeatures: dom-overlay,unbounded;
				overlayElement: #overlay;">
			<a-camera user-height="0"></a-camera>
			<a-gltf-model id="virtualObject" src="separated_colored.glb" scale="0.1 0.1 0.1" position="0 0 -40" rotation="0 -90 0" shadow="cast: true"></a-gltf-model>
		</a-scene>
		<script>
			class ARCoachingOverlayView : UIView
			
			func setGoal() {
				coachingOverlay.goal = .horizontalPlane
			}
			func setActivatesAutomatically() {
				coachingOverlay.activatesAutomatically = true
			}
			func coachingOverlayViewWillActivate(_ coachingOverlayView: ARCoachingOverlayView) {
				upperControlsView.isHidden = true
			}
			func coachingOverlayViewDidDeactivate(_ coachingOverlayView: ARCoachingOverlayView) {
				upperControlsView.isHidden = false
			}
			func getRaycastQuery(for alignment: ARRaycastQuery.TargetAlignment = .any) -> ARRaycastQuery? {
				return raycastQuery(from: screenCenter, allowing: .estimatedPlane, alignment: alignment)
			}
			func castRay(for query: ARRaycastQuery) -> [ARRaycastResult] {
				return session.raycast(query)
			}
			func setPosition(with raycastResult: ARRaycastResult, _ camera: ARCamera?) {
				let position = raycastResult.worldTransform.translation
				recentFocusSquarePositions.append(position)
				updateTransform(for: raycastResult, camera: camera)
			}
			func updateOrientation(basedOn raycastResult: ARRaycastResult) {
				self.simdOrientation = raycastResult.worldTransform.orientation
			}
			func placeVirtualObject(_ virtualObject: VirtualObject) {
				guard focusSquare.state != .initializing, let query = virtualObject.raycastQuery else {
				self.statusViewController.showMessage("CANNOT PLACE OBJECT\nTry moving left or right.")
				if let controller = self.objectsViewController {
				    self.virtualObjectSelectionViewController(controller, didDeselectObject: virtualObject)
				}
				return
				}

				let trackedRaycast = createTrackedRaycastAndSet3DPosition(of: virtualObject, from: query,
										      withInitialResult: virtualObject.mostRecentInitialPlacementResult)

				virtualObject.raycast = trackedRaycast
				virtualObjectInteraction.selectedObject = virtualObject
				virtualObject.isHidden = false
			}
			func createTrackedRaycastAndSet3DPosition(of virtualObject: VirtualObject, from query: ARRaycastQuery,
                                          withInitialResult initialResult: ARRaycastResult? = nil) -> ARTrackedRaycast? {
				if let initialResult = initialResult {
				self.setTransform(of: virtualObject, with: initialResult)
				}

				return session.trackedRaycast(query) { (results) in
				self.setVirtualObject3DPosition(results, with: virtualObject)
				}
			}
			private func setVirtualObject3DPosition(_ results: [ARRaycastResult], with virtualObject: VirtualObject) {
			    guard let result = results.first else {
				fatalError("Unexpected case: the update handler is always supposed to return at least one result.")
			    }

			    self.setTransform(of: virtualObject, with: result)

			    // If the virtual object is not yet in the scene, add it.
			    if virtualObject.parent == nil {
				self.sceneView.scene.rootNode.addChildNode(virtualObject)
				virtualObject.shouldUpdateAnchor = true
			    }

			    if virtualObject.shouldUpdateAnchor {
				virtualObject.shouldUpdateAnchor = false
				self.updateQueue.async {
				    self.sceneView.addOrUpdateAnchor(for: virtualObject)
				}
			    }
			}
			func removeVirtualObject(at index: Int) {
				guard loadedObjects.indices.contains(index) else { return }

				// Stop the object's tracked ray cast.
				loadedObjects[index].stopTrackedRaycast()

				// Remove the visual node from the scene graph.
				loadedObjects[index].removeFromParentNode()
				// Recoup resources allocated by the object.
				loadedObjects[index].unload()
				loadedObjects.remove(at: index)
			}
			func stopTrackedRaycast() {
				raycast?.stopTracking()
				raycast = nil
			}
			func createPanGestureRecognizer(_ sceneView: VirtualObjectARView) {
				let panGesture = ThresholdPanGesture(target: self, action: #selector(didPan(_:)))
				panGesture.delegate = self
				sceneView.addGestureRecognizer(panGesture)
			}
			func translate(_ object: VirtualObject, basedOn screenPos: CGPoint) {
				object.stopTrackedRaycast()

				// Update the object by using a one-time position request.
				if let query = sceneView.raycastQuery(from: screenPos, allowing: .estimatedPlane, alignment: object.allowedAlignment) {
				viewController.createRaycastAndUpdate3DPosition(of: object, from: query)
				}
			}
			@objc
			func didRotate(_ gesture: UIRotationGestureRecognizer) {
				guard gesture.state == .changed else { return }

				trackedObject?.objectRotation -= Float(gesture.rotation)

				gesture.rotation = 0
			}
		</script>
	</body>
</html>
